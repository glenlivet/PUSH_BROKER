var events = require('events')
  , util = require('util')
  , protocol = require('./protocol')
  , generate = require('./generate')
  , parse = require('./parse')
  , bufferSize = 1024; // we need fast buffers!!

var Connection = module.exports = 
function Connection(stream, server) {
  this.server = server;
  this.stream = stream;
  this.buffer = null;
  this.packet = {};
  var that = this;
  this.stream.on('data', function (buf) {
    that.parse(buf);
  });

  events.EventEmitter.call(this);
};
util.inherits(Connection, events.EventEmitter);

Connection.prototype.parse = function(buf) {
	if(null !== this.buffer){
		//if there's unread buffer from last call,
		//add to the current buf
		buf = Buffer.concat([this.buffer, buf], 
					this.buffer.length + buf.length);
	
	}

	var pos = 0, 					//next read position
		len = buf.length;			//total buf length
	
	if('undefined' !== typeof buf[0]){
		if(!this.packet.cmd){
			//parse the header
			parse['header'](buf.slice(0,1), this.packet);
			pos++;
		}
		if(!this.packet.length){
			//parse the remaining length
			var tmp = {mul: 1, length: 0};
			var _pos = pos;			//trying to read remaining length, record the read position
									//may fail if lack of available data, 
									//so use `_pos` instead of munipulating directly on `pos`
			do{
				if(_pos >= len){
					//not enough data 
					//record the unread buffer 
					this.buffer = buf.slice(pos, len);
					return;
				}
				tmp.length += 
					tmp.mul *(buf[_pos] & protocol.LENGTH_MASK);
				tmp.mul *= 0x80;
			}while(
				(buf[_pos++] & protocol.LENGTH_FIN_MASK) !== 0
			);
			//successfully read the remaining length
			//record and set `pos` to the right position
			this.packet.length = tmp.length;
			pos = _pos;
			if('publish' === this.packet.cmd)
				console.log('remaining length: ' + this.packet.length); 
				
		}
		if(len - pos < this.packet.length){
			//not enough data for variable header & payload
			//record the unread buffer, then return
			this.buffer = buf.slice(pos, len);
			return;
		}else{
			//enough
			parse[this.packet.cmd](
				buf.slice(pos, this.packet.length + pos), 
				this.packet
			);
			//renew the read position
			pos += this.packet.length;
			//emit event
			this.emit(this.packet.cmd, this.packet);
			//reset packet
			this.packet = {};
			
		}
		
		if(pos < len){
			//still have some data, 
			//must belong to the next mqtt message
			//record in buffer
			this.buffer = buf.slice(pos, len);
		}else{
			//no data left
			//clear buffer
			this.buffer = null;
		}
	}
	
};

for (var k in protocol.types) {
  var v = protocol.types[k];

  Connection.prototype[v] = function(type) {
    return function(opts) {
      var p = generate[type](opts);
      if (p instanceof Error) {
        this.emit('error', p)
      } else {
      	if(this.stream.writable)
        	this.stream.write(p);
      }
    }
  }(v);
}

